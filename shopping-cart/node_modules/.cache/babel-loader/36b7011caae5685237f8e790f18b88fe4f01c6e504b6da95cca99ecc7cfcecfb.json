{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { warnOnce } from '@mui/x-internals/warning';\nexport const sanitizeSortModel = (model, disableMultipleColumnsSorting) => {\n  if (disableMultipleColumnsSorting && model.length > 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      warnOnce(['MUI X: The `sortModel` can only contain a single item when the `disableMultipleColumnsSorting` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\n    }\n    return [model[0]];\n  }\n  return model;\n};\nexport const mergeStateWithSortModel = (sortModel, disableMultipleColumnsSorting) => state => _extends({}, state, {\n  sorting: _extends({}, state.sorting, {\n    sortModel: sanitizeSortModel(sortModel, disableMultipleColumnsSorting)\n  })\n});\nconst isDesc = direction => direction === 'desc';\n\n/**\n * Transform an item of the sorting model into a method comparing two rows.\n * @param {GridSortItem} sortItem The sort item we want to apply.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridParsedSortItem | null} The parsed sort item. Returns `null` is the sort item is not valid.\n */\nconst parseSortItem = (sortItem, apiRef) => {\n  const column = apiRef.current.getColumn(sortItem.field);\n  if (!column || sortItem.sort === null) {\n    return null;\n  }\n  let comparator;\n  if (column.getSortComparator) {\n    comparator = column.getSortComparator(sortItem.sort);\n  } else {\n    comparator = isDesc(sortItem.sort) ? (...args) => -1 * column.sortComparator(...args) : column.sortComparator;\n  }\n  if (!comparator) {\n    return null;\n  }\n  const getSortCellParams = id => ({\n    id,\n    field: column.field,\n    rowNode: apiRef.current.getRowNode(id),\n    value: apiRef.current.getCellValue(id, column.field),\n    api: apiRef.current\n  });\n  return {\n    getSortCellParams,\n    comparator\n  };\n};\n/**\n * Compare two rows according to a list of valid sort items.\n * The `row1Params` and `row2Params` must have the same length as `parsedSortItems`,\n * and each of their index must contain the `GridSortCellParams` of the sort item with the same index.\n * @param {GridParsedSortItem[]} parsedSortItems All the sort items with which we want to compare the rows.\n * @param {GridRowAggregatedSortingParams} row1 The node and params of the 1st row for each sort item.\n * @param {GridRowAggregatedSortingParams} row2 The node and params of the 2nd row for each sort item.\n */\nconst compareRows = (parsedSortItems, row1, row2) => {\n  return parsedSortItems.reduce((res, item, index) => {\n    if (res !== 0) {\n      // return the results of the first comparator which distinguish the two rows\n      return res;\n    }\n    const sortCellParams1 = row1.params[index];\n    const sortCellParams2 = row2.params[index];\n    res = item.comparator(sortCellParams1.value, sortCellParams2.value, sortCellParams1, sortCellParams2);\n    return res;\n  }, 0);\n};\n\n/**\n * Generates a method to easily sort a list of rows according to the current sort model.\n * @param {GridSortModel} sortModel The model with which we want to sort the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridSortingModelApplier | null} A method that generates a list of sorted row ids from a list of rows according to the current sort model. If `null`, we consider that the rows should remain in the order there were provided.\n */\nexport const buildAggregatedSortingApplier = (sortModel, apiRef) => {\n  const comparatorList = sortModel.map(item => parseSortItem(item, apiRef)).filter(comparator => !!comparator);\n  if (comparatorList.length === 0) {\n    return null;\n  }\n  return rowList => rowList.map(node => ({\n    node,\n    params: comparatorList.map(el => el.getSortCellParams(node.id))\n  })).sort((a, b) => compareRows(comparatorList, a, b)).map(row => row.node.id);\n};\nexport const getNextGridSortDirection = (sortingOrder, current) => {\n  const currentIdx = sortingOrder.indexOf(current);\n  if (!current || currentIdx === -1 || currentIdx + 1 === sortingOrder.length) {\n    return sortingOrder[0];\n  }\n  return sortingOrder[currentIdx + 1];\n};\nconst gridNillComparator = (v1, v2) => {\n  if (v1 == null && v2 != null) {\n    return -1;\n  }\n  if (v2 == null && v1 != null) {\n    return 1;\n  }\n  if (v1 == null && v2 == null) {\n    return 0;\n  }\n  return null;\n};\nconst collator = new Intl.Collator();\nexport const gridStringOrNumberComparator = (value1, value2) => {\n  const nillResult = gridNillComparator(value1, value2);\n  if (nillResult !== null) {\n    return nillResult;\n  }\n  if (typeof value1 === 'string') {\n    return collator.compare(value1.toString(), value2.toString());\n  }\n  return value1 - value2;\n};\nexport const gridNumberComparator = (value1, value2) => {\n  const nillResult = gridNillComparator(value1, value2);\n  if (nillResult !== null) {\n    return nillResult;\n  }\n  return Number(value1) - Number(value2);\n};\nexport const gridDateComparator = (value1, value2) => {\n  const nillResult = gridNillComparator(value1, value2);\n  if (nillResult !== null) {\n    return nillResult;\n  }\n  if (value1 > value2) {\n    return 1;\n  }\n  if (value1 < value2) {\n    return -1;\n  }\n  return 0;\n};","map":{"version":3,"names":["_extends","warnOnce","sanitizeSortModel","model","disableMultipleColumnsSorting","length","process","env","NODE_ENV","mergeStateWithSortModel","sortModel","state","sorting","isDesc","direction","parseSortItem","sortItem","apiRef","column","current","getColumn","field","sort","comparator","getSortComparator","args","sortComparator","getSortCellParams","id","rowNode","getRowNode","value","getCellValue","api","compareRows","parsedSortItems","row1","row2","reduce","res","item","index","sortCellParams1","params","sortCellParams2","buildAggregatedSortingApplier","comparatorList","map","filter","rowList","node","el","a","b","row","getNextGridSortDirection","sortingOrder","currentIdx","indexOf","gridNillComparator","v1","v2","collator","Intl","Collator","gridStringOrNumberComparator","value1","value2","nillResult","compare","toString","gridNumberComparator","Number","gridDateComparator"],"sources":["D:/Documents/shopping-cart-react/shopping-cart/node_modules/@mui/x-data-grid/hooks/features/sorting/gridSortingUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { warnOnce } from '@mui/x-internals/warning';\nexport const sanitizeSortModel = (model, disableMultipleColumnsSorting) => {\n  if (disableMultipleColumnsSorting && model.length > 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      warnOnce(['MUI X: The `sortModel` can only contain a single item when the `disableMultipleColumnsSorting` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\n    }\n    return [model[0]];\n  }\n  return model;\n};\nexport const mergeStateWithSortModel = (sortModel, disableMultipleColumnsSorting) => state => _extends({}, state, {\n  sorting: _extends({}, state.sorting, {\n    sortModel: sanitizeSortModel(sortModel, disableMultipleColumnsSorting)\n  })\n});\nconst isDesc = direction => direction === 'desc';\n\n/**\n * Transform an item of the sorting model into a method comparing two rows.\n * @param {GridSortItem} sortItem The sort item we want to apply.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridParsedSortItem | null} The parsed sort item. Returns `null` is the sort item is not valid.\n */\nconst parseSortItem = (sortItem, apiRef) => {\n  const column = apiRef.current.getColumn(sortItem.field);\n  if (!column || sortItem.sort === null) {\n    return null;\n  }\n  let comparator;\n  if (column.getSortComparator) {\n    comparator = column.getSortComparator(sortItem.sort);\n  } else {\n    comparator = isDesc(sortItem.sort) ? (...args) => -1 * column.sortComparator(...args) : column.sortComparator;\n  }\n  if (!comparator) {\n    return null;\n  }\n  const getSortCellParams = id => ({\n    id,\n    field: column.field,\n    rowNode: apiRef.current.getRowNode(id),\n    value: apiRef.current.getCellValue(id, column.field),\n    api: apiRef.current\n  });\n  return {\n    getSortCellParams,\n    comparator\n  };\n};\n/**\n * Compare two rows according to a list of valid sort items.\n * The `row1Params` and `row2Params` must have the same length as `parsedSortItems`,\n * and each of their index must contain the `GridSortCellParams` of the sort item with the same index.\n * @param {GridParsedSortItem[]} parsedSortItems All the sort items with which we want to compare the rows.\n * @param {GridRowAggregatedSortingParams} row1 The node and params of the 1st row for each sort item.\n * @param {GridRowAggregatedSortingParams} row2 The node and params of the 2nd row for each sort item.\n */\nconst compareRows = (parsedSortItems, row1, row2) => {\n  return parsedSortItems.reduce((res, item, index) => {\n    if (res !== 0) {\n      // return the results of the first comparator which distinguish the two rows\n      return res;\n    }\n    const sortCellParams1 = row1.params[index];\n    const sortCellParams2 = row2.params[index];\n    res = item.comparator(sortCellParams1.value, sortCellParams2.value, sortCellParams1, sortCellParams2);\n    return res;\n  }, 0);\n};\n\n/**\n * Generates a method to easily sort a list of rows according to the current sort model.\n * @param {GridSortModel} sortModel The model with which we want to sort the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridSortingModelApplier | null} A method that generates a list of sorted row ids from a list of rows according to the current sort model. If `null`, we consider that the rows should remain in the order there were provided.\n */\nexport const buildAggregatedSortingApplier = (sortModel, apiRef) => {\n  const comparatorList = sortModel.map(item => parseSortItem(item, apiRef)).filter(comparator => !!comparator);\n  if (comparatorList.length === 0) {\n    return null;\n  }\n  return rowList => rowList.map(node => ({\n    node,\n    params: comparatorList.map(el => el.getSortCellParams(node.id))\n  })).sort((a, b) => compareRows(comparatorList, a, b)).map(row => row.node.id);\n};\nexport const getNextGridSortDirection = (sortingOrder, current) => {\n  const currentIdx = sortingOrder.indexOf(current);\n  if (!current || currentIdx === -1 || currentIdx + 1 === sortingOrder.length) {\n    return sortingOrder[0];\n  }\n  return sortingOrder[currentIdx + 1];\n};\nconst gridNillComparator = (v1, v2) => {\n  if (v1 == null && v2 != null) {\n    return -1;\n  }\n  if (v2 == null && v1 != null) {\n    return 1;\n  }\n  if (v1 == null && v2 == null) {\n    return 0;\n  }\n  return null;\n};\nconst collator = new Intl.Collator();\nexport const gridStringOrNumberComparator = (value1, value2) => {\n  const nillResult = gridNillComparator(value1, value2);\n  if (nillResult !== null) {\n    return nillResult;\n  }\n  if (typeof value1 === 'string') {\n    return collator.compare(value1.toString(), value2.toString());\n  }\n  return value1 - value2;\n};\nexport const gridNumberComparator = (value1, value2) => {\n  const nillResult = gridNillComparator(value1, value2);\n  if (nillResult !== null) {\n    return nillResult;\n  }\n  return Number(value1) - Number(value2);\n};\nexport const gridDateComparator = (value1, value2) => {\n  const nillResult = gridNillComparator(value1, value2);\n  if (nillResult !== null) {\n    return nillResult;\n  }\n  if (value1 > value2) {\n    return 1;\n  }\n  if (value1 < value2) {\n    return -1;\n  }\n  return 0;\n};"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,SAASC,QAAQ,QAAQ,0BAA0B;AACnD,OAAO,MAAMC,iBAAiB,GAAGA,CAACC,KAAK,EAAEC,6BAA6B,KAAK;EACzE,IAAIA,6BAA6B,IAAID,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;IACrD,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzCP,QAAQ,CAAC,CAAC,uHAAuH,EAAE,uFAAuF,CAAC,EAAE,OAAO,CAAC;IACvO;IACA,OAAO,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC;EACnB;EACA,OAAOA,KAAK;AACd,CAAC;AACD,OAAO,MAAMM,uBAAuB,GAAGA,CAACC,SAAS,EAAEN,6BAA6B,KAAKO,KAAK,IAAIX,QAAQ,CAAC,CAAC,CAAC,EAAEW,KAAK,EAAE;EAChHC,OAAO,EAAEZ,QAAQ,CAAC,CAAC,CAAC,EAAEW,KAAK,CAACC,OAAO,EAAE;IACnCF,SAAS,EAAER,iBAAiB,CAACQ,SAAS,EAAEN,6BAA6B;EACvE,CAAC;AACH,CAAC,CAAC;AACF,MAAMS,MAAM,GAAGC,SAAS,IAAIA,SAAS,KAAK,MAAM;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,aAAa,GAAGA,CAACC,QAAQ,EAAEC,MAAM,KAAK;EAC1C,MAAMC,MAAM,GAAGD,MAAM,CAACE,OAAO,CAACC,SAAS,CAACJ,QAAQ,CAACK,KAAK,CAAC;EACvD,IAAI,CAACH,MAAM,IAAIF,QAAQ,CAACM,IAAI,KAAK,IAAI,EAAE;IACrC,OAAO,IAAI;EACb;EACA,IAAIC,UAAU;EACd,IAAIL,MAAM,CAACM,iBAAiB,EAAE;IAC5BD,UAAU,GAAGL,MAAM,CAACM,iBAAiB,CAACR,QAAQ,CAACM,IAAI,CAAC;EACtD,CAAC,MAAM;IACLC,UAAU,GAAGV,MAAM,CAACG,QAAQ,CAACM,IAAI,CAAC,GAAG,CAAC,GAAGG,IAAI,KAAK,CAAC,CAAC,GAAGP,MAAM,CAACQ,cAAc,CAAC,GAAGD,IAAI,CAAC,GAAGP,MAAM,CAACQ,cAAc;EAC/G;EACA,IAAI,CAACH,UAAU,EAAE;IACf,OAAO,IAAI;EACb;EACA,MAAMI,iBAAiB,GAAGC,EAAE,KAAK;IAC/BA,EAAE;IACFP,KAAK,EAAEH,MAAM,CAACG,KAAK;IACnBQ,OAAO,EAAEZ,MAAM,CAACE,OAAO,CAACW,UAAU,CAACF,EAAE,CAAC;IACtCG,KAAK,EAAEd,MAAM,CAACE,OAAO,CAACa,YAAY,CAACJ,EAAE,EAAEV,MAAM,CAACG,KAAK,CAAC;IACpDY,GAAG,EAAEhB,MAAM,CAACE;EACd,CAAC,CAAC;EACF,OAAO;IACLQ,iBAAiB;IACjBJ;EACF,CAAC;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMW,WAAW,GAAGA,CAACC,eAAe,EAAEC,IAAI,EAAEC,IAAI,KAAK;EACnD,OAAOF,eAAe,CAACG,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,EAAEC,KAAK,KAAK;IAClD,IAAIF,GAAG,KAAK,CAAC,EAAE;MACb;MACA,OAAOA,GAAG;IACZ;IACA,MAAMG,eAAe,GAAGN,IAAI,CAACO,MAAM,CAACF,KAAK,CAAC;IAC1C,MAAMG,eAAe,GAAGP,IAAI,CAACM,MAAM,CAACF,KAAK,CAAC;IAC1CF,GAAG,GAAGC,IAAI,CAACjB,UAAU,CAACmB,eAAe,CAACX,KAAK,EAAEa,eAAe,CAACb,KAAK,EAAEW,eAAe,EAAEE,eAAe,CAAC;IACrG,OAAOL,GAAG;EACZ,CAAC,EAAE,CAAC,CAAC;AACP,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMM,6BAA6B,GAAGA,CAACnC,SAAS,EAAEO,MAAM,KAAK;EAClE,MAAM6B,cAAc,GAAGpC,SAAS,CAACqC,GAAG,CAACP,IAAI,IAAIzB,aAAa,CAACyB,IAAI,EAAEvB,MAAM,CAAC,CAAC,CAAC+B,MAAM,CAACzB,UAAU,IAAI,CAAC,CAACA,UAAU,CAAC;EAC5G,IAAIuB,cAAc,CAACzC,MAAM,KAAK,CAAC,EAAE;IAC/B,OAAO,IAAI;EACb;EACA,OAAO4C,OAAO,IAAIA,OAAO,CAACF,GAAG,CAACG,IAAI,KAAK;IACrCA,IAAI;IACJP,MAAM,EAAEG,cAAc,CAACC,GAAG,CAACI,EAAE,IAAIA,EAAE,CAACxB,iBAAiB,CAACuB,IAAI,CAACtB,EAAE,CAAC;EAChE,CAAC,CAAC,CAAC,CAACN,IAAI,CAAC,CAAC8B,CAAC,EAAEC,CAAC,KAAKnB,WAAW,CAACY,cAAc,EAAEM,CAAC,EAAEC,CAAC,CAAC,CAAC,CAACN,GAAG,CAACO,GAAG,IAAIA,GAAG,CAACJ,IAAI,CAACtB,EAAE,CAAC;AAC/E,CAAC;AACD,OAAO,MAAM2B,wBAAwB,GAAGA,CAACC,YAAY,EAAErC,OAAO,KAAK;EACjE,MAAMsC,UAAU,GAAGD,YAAY,CAACE,OAAO,CAACvC,OAAO,CAAC;EAChD,IAAI,CAACA,OAAO,IAAIsC,UAAU,KAAK,CAAC,CAAC,IAAIA,UAAU,GAAG,CAAC,KAAKD,YAAY,CAACnD,MAAM,EAAE;IAC3E,OAAOmD,YAAY,CAAC,CAAC,CAAC;EACxB;EACA,OAAOA,YAAY,CAACC,UAAU,GAAG,CAAC,CAAC;AACrC,CAAC;AACD,MAAME,kBAAkB,GAAGA,CAACC,EAAE,EAAEC,EAAE,KAAK;EACrC,IAAID,EAAE,IAAI,IAAI,IAAIC,EAAE,IAAI,IAAI,EAAE;IAC5B,OAAO,CAAC,CAAC;EACX;EACA,IAAIA,EAAE,IAAI,IAAI,IAAID,EAAE,IAAI,IAAI,EAAE;IAC5B,OAAO,CAAC;EACV;EACA,IAAIA,EAAE,IAAI,IAAI,IAAIC,EAAE,IAAI,IAAI,EAAE;IAC5B,OAAO,CAAC;EACV;EACA,OAAO,IAAI;AACb,CAAC;AACD,MAAMC,QAAQ,GAAG,IAAIC,IAAI,CAACC,QAAQ,CAAC,CAAC;AACpC,OAAO,MAAMC,4BAA4B,GAAGA,CAACC,MAAM,EAAEC,MAAM,KAAK;EAC9D,MAAMC,UAAU,GAAGT,kBAAkB,CAACO,MAAM,EAAEC,MAAM,CAAC;EACrD,IAAIC,UAAU,KAAK,IAAI,EAAE;IACvB,OAAOA,UAAU;EACnB;EACA,IAAI,OAAOF,MAAM,KAAK,QAAQ,EAAE;IAC9B,OAAOJ,QAAQ,CAACO,OAAO,CAACH,MAAM,CAACI,QAAQ,CAAC,CAAC,EAAEH,MAAM,CAACG,QAAQ,CAAC,CAAC,CAAC;EAC/D;EACA,OAAOJ,MAAM,GAAGC,MAAM;AACxB,CAAC;AACD,OAAO,MAAMI,oBAAoB,GAAGA,CAACL,MAAM,EAAEC,MAAM,KAAK;EACtD,MAAMC,UAAU,GAAGT,kBAAkB,CAACO,MAAM,EAAEC,MAAM,CAAC;EACrD,IAAIC,UAAU,KAAK,IAAI,EAAE;IACvB,OAAOA,UAAU;EACnB;EACA,OAAOI,MAAM,CAACN,MAAM,CAAC,GAAGM,MAAM,CAACL,MAAM,CAAC;AACxC,CAAC;AACD,OAAO,MAAMM,kBAAkB,GAAGA,CAACP,MAAM,EAAEC,MAAM,KAAK;EACpD,MAAMC,UAAU,GAAGT,kBAAkB,CAACO,MAAM,EAAEC,MAAM,CAAC;EACrD,IAAIC,UAAU,KAAK,IAAI,EAAE;IACvB,OAAOA,UAAU;EACnB;EACA,IAAIF,MAAM,GAAGC,MAAM,EAAE;IACnB,OAAO,CAAC;EACV;EACA,IAAID,MAAM,GAAGC,MAAM,EAAE;IACnB,OAAO,CAAC,CAAC;EACX;EACA,OAAO,CAAC;AACV,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}